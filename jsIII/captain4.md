# 第四章 变量、作用域和内存问题
> VO和AO?
  - 变量对象定义着一个函数内的函数参数、内部变量和内部函数
  - 创建变量对象的过程实际就是函数内数据(函数参数、内部变量、内部函数)初始化的过程
  - 未进入执行阶段前，变量对象的属性不能访问，但是进入执行阶段后，变量对象转变为活动对象，即可访问内部属性，然后开始进行执行阶段的操作。所以活动对象实际就是变量对象在真正执行时的另一种形式
- JavaScript变量松散类型的本质，决定了它只能在特定的时间用于保存特定值的一个名字而已，由于不存在定义某个变量必须保存何种数据类型值的规则，变量的值及数据类型可以在脚本的生命周期内改变

## 4.1 基本类型和引用类型的值
- 基本类型：简单数据段
  - 5中基本数据类型：Undefined, Null, Boolean, Number, String
  - 变量保存在值中(栈内存)，可以直接操作保存在值中的对象
- 引用类型：可能由多个值构成的对象
  - 变量是保存在内存中的对象(堆内存)，当复制时，操作的只是引用；添加对象属性时操作的是内存中实际的对象

### 4.1.1 动态属性
- 基本类型无法添加动态属性；引用类型可以添加动态属性

### 4.1.2 复制变量值
- 基本类型复制的是值，保存为一个副本
- 引用类型复制的是指针，指向内存中的位置

### 4.1.3 传递参数
- 所有函数参数都是按值传递的
- 向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，arguments对象中的一个元素)
- 向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部

### 4.1.4 检测类型
- 基本类型：typeof()
  - 返回string, boolean, number, undefined, object, function
  - typeof(null) === object
- 引用类型：instanceof()
  - 如果用instanceof()检测基本类型，会返回false

## 4.2 执行环境及作用域
- 执行环境定义了变量有权访问的其他数据，决定了它们各自的行为
- 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中
- 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中
- 当代码在一个环境中执行时，会创建变量对象的一个作用域链；作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问
> 每个函数创建的同时会创建一个包含全局环境的作用域链保存在该函数的[Scope]属性中，在该函数被调用的时候，会创建一个执行环境，将保存在[Scope]属性中的作用域链的对象进行复制；作用域链中的对象都是一个指针，只是引用，不包含实际变量

### 4.2.1 延长作用域链
- try-catch语句的catch块
- with语句

### 4.2.2 没有块级作用域
#### 1 变量声明
- 使用var声明的变量会自动添加到最接近环境中
- 初始化变量时没有使用var声明，该变量会自动被添加到全局环境
#### 2 查询表示符
> 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到
了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
着该变量尚未声明

## 4.3 垃圾收集

### 4.3.1 标记清除

### 4.3.2 引用计数
- 跟踪记录所有值的引用次数
- 当出现循环引用的时候，会导致引用次数始终不为0，导致内存泄露
- IE的DOM和BOM对象是使用C++以COM对象的形式实现的，COM对象的垃圾处理形式就是引用计数，所以IE中的DOM和BOM也存在相同的问题，需要手动null释放内存

### 4.3.3 内存管理
- 局部变量会在局部作用域销毁时一起销毁
- 全局变量会一直存在内存中，一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。
